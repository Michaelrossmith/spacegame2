import { useEffect, useRef, useState } from 'react';
import { Label } from './ui/label';
import { Slider } from './ui/slider';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from './ui/select';
import { Tabs, TabsContent, TabsList, TabsTrigger } from './ui/tabs';

type ShapeType = 'sphere' | 'cube' | 'torus' | 'cylinder' | 'satellite' | 'dish' | 'debris' | 'cross' | 'octahedron' | 'capsule';

interface Vector3 {
  x: number;
  y: number;
  z: number;
}

export function LidarSimulator() {
  // Shared state
  const [shapeType, setShapeType] = useState<ShapeType>('sphere');
  const [shapeSize, setShapeSize] = useState(1);
  const [rotationX, setRotationX] = useState(20);
  const [rotationY, setRotationY] = useState(30);

  // LIDAR-specific state
  const lidarCanvasRef = useRef<HTMLCanvasElement>(null);
  const [pixelSize, setPixelSize] = useState(4);
  const [dotSize, setDotSize] = useState(2);
  const [rayCount, setRayCount] = useState(5000);
  const [projectionAngle, setProjectionAngle] = useState(45);
  const [distance, setDistance] = useState(3);

  // Cross-section-specific state
  const crossSectionCanvasRef = useRef<HTMLCanvasElement>(null);
  const [slicePosition, setSlicePosition] = useState(0);
  const [crossPixelSize, setCrossPixelSize] = useState(4);
  const [crossDotSize, setCrossDotSize] = useState(3);

  // LIDAR rendering effect
  useEffect(() => {
    const canvas = lidarCanvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    const width = canvas.width;
    const height = canvas.height;

    ctx.fillStyle = '#000000';
    ctx.fillRect(0, 0, width, height);

    const camera: Vector3 = { x: 0, y: 0, z: distance };
    const hits: Vector3[] = [];
    const angleRad = (projectionAngle * Math.PI) / 180;

    for (let i = 0; i < rayCount; i++) {
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.random() * angleRad;

      const dir: Vector3 = {
        x: Math.sin(phi) * Math.cos(theta),
        y: Math.sin(phi) * Math.sin(theta),
        z: -Math.cos(phi),
      };

      const hit = castRay(camera, dir, shapeType, rotationX, rotationY, shapeSize);
      if (hit) {
        hits.push(hit);
      }
    }

    hits.forEach((point) => {
      const projected = project3DTo2D(point, width, height);
      if (projected) {
        ctx.fillStyle = '#FFFFFF';
        ctx.fillRect(
          Math.floor(projected.x / pixelSize) * pixelSize,
          Math.floor(projected.y / pixelSize) * pixelSize,
          dotSize,
          dotSize
        );
      }
    });
  }, [shapeType, pixelSize, dotSize, rayCount, projectionAngle, rotationX, rotationY, distance, shapeSize]);

  // Cross-section rendering effect
  useEffect(() => {
    const canvas = crossSectionCanvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    const width = canvas.width;
    const height = canvas.height;

    ctx.fillStyle = '#000000';
    ctx.fillRect(0, 0, width, height);

    // Calculate color based on slice position
    const colorValue = Math.floor(((slicePosition + 2) / 4) * 255);
    const color = `rgb(${255 - colorValue}, ${colorValue}, ${128})`;

    const resolution = 400;
    const scale = 150;

    for (let px = 0; px < resolution; px++) {
      for (let py = 0; py < resolution; py++) {
        const x = ((px - resolution / 2) / scale) * shapeSize * 2;
        const y = ((py - resolution / 2) / scale) * shapeSize * 2;

        // Fixed slice plane at z = slicePosition in world space
        const worldPoint: Vector3 = { x, y, z: slicePosition };

        // Apply inverse rotation to check if point is inside rotated shape
        const localPoint = rotatePoint(worldPoint, -rotationX, -rotationY);

        if (isPointInShape(localPoint, shapeType, shapeSize)) {
          const screenX = Math.floor(px / crossPixelSize) * crossPixelSize;
          const screenY = Math.floor(py / crossPixelSize) * crossPixelSize;
          
          ctx.fillStyle = color;
          ctx.fillRect(screenX, screenY, crossDotSize, crossDotSize);
        }
      }
    }
  }, [shapeType, shapeSize, rotationX, rotationY, slicePosition, crossPixelSize, crossDotSize]);

  return (
    <Tabs defaultValue="lidar" className="size-full flex flex-col bg-gray-100">
      <div className="px-8 pt-6">
        <TabsList className="grid w-full max-w-md grid-cols-2">
          <TabsTrigger value="lidar">LIDAR Scanner</TabsTrigger>
          <TabsTrigger value="crosssection">Cross Section</TabsTrigger>
        </TabsList>
      </div>

      <TabsContent value="lidar" className="flex-1 flex gap-8 px-8 pb-8 mt-4">
        <div className="flex-1 flex items-center justify-center bg-white rounded-lg shadow-lg">
          <canvas
            ref={lidarCanvasRef}
            width={800}
            height={800}
            className="border border-gray-300"
          />
        </div>

        <div className="w-80 space-y-6 overflow-auto">
          <div>
            <h2 className="mb-4">LIDAR Controls</h2>

            <div className="space-y-4">
              <div>
                <Label htmlFor="shape-lidar">Shape Type</Label>
                <Select value={shapeType} onValueChange={(value) => setShapeType(value as ShapeType)}>
                  <SelectTrigger id="shape-lidar">
                    <SelectValue />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="sphere">Sphere</SelectItem>
                    <SelectItem value="cube">Cube</SelectItem>
                    <SelectItem value="torus">Torus</SelectItem>
                    <SelectItem value="cylinder">Cylinder</SelectItem>
                    <SelectItem value="satellite">Satellite</SelectItem>
                    <SelectItem value="dish">Dish</SelectItem>
                    <SelectItem value="debris">Debris</SelectItem>
                    <SelectItem value="cross">Cross</SelectItem>
                    <SelectItem value="octahedron">Octahedron</SelectItem>
                    <SelectItem value="capsule">Capsule</SelectItem>
                  </SelectContent>
                </Select>
              </div>

              <div>
                <Label htmlFor="pixelSize">Pixel Size: {pixelSize}px</Label>
                <Slider
                  id="pixelSize"
                  min={1}
                  max={10}
                  step={1}
                  value={[pixelSize]}
                  onValueChange={(value) => setPixelSize(value[0])}
                />
              </div>

              <div>
                <Label htmlFor="dotSize">Dot Size: {dotSize}px</Label>
                <Slider
                  id="dotSize"
                  min={1}
                  max={10}
                  step={1}
                  value={[dotSize]}
                  onValueChange={(value) => setDotSize(value[0])}
                />
              </div>

              <div>
                <Label htmlFor="rayCount">Ray Count: {rayCount}</Label>
                <Slider
                  id="rayCount"
                  min={500}
                  max={20000}
                  step={500}
                  value={[rayCount]}
                  onValueChange={(value) => setRayCount(value[0])}
                />
              </div>

              <div>
                <Label htmlFor="projectionAngle">Projection Angle: {projectionAngle}°</Label>
                <Slider
                  id="projectionAngle"
                  min={10}
                  max={90}
                  step={5}
                  value={[projectionAngle]}
                  onValueChange={(value) => setProjectionAngle(value[0])}
                />
              </div>

              <div>
                <Label htmlFor="distance">Camera Distance: {distance.toFixed(1)}</Label>
                <Slider
                  id="distance"
                  min={1.5}
                  max={5}
                  step={0.1}
                  value={[distance]}
                  onValueChange={(value) => setDistance(value[0])}
                />
              </div>

              <div>
                <Label htmlFor="shapeSize-lidar">Shape Size: {shapeSize.toFixed(1)}</Label>
                <Slider
                  id="shapeSize-lidar"
                  min={0.5}
                  max={2}
                  step={0.1}
                  value={[shapeSize]}
                  onValueChange={(value) => setShapeSize(value[0])}
                />
              </div>

              <div>
                <Label htmlFor="rotationX-lidar">Rotation X: {rotationX}°</Label>
                <Slider
                  id="rotationX-lidar"
                  min={0}
                  max={360}
                  step={5}
                  value={[rotationX]}
                  onValueChange={(value) => setRotationX(value[0])}
                />
              </div>

              <div>
                <Label htmlFor="rotationY-lidar">Rotation Y: {rotationY}°</Label>
                <Slider
                  id="rotationY-lidar"
                  min={0}
                  max={360}
                  step={5}
                  value={[rotationY]}
                  onValueChange={(value) => setRotationY(value[0])}
                />
              </div>
            </div>
          </div>
        </div>
      </TabsContent>

      <TabsContent value="crosssection" className="flex-1 flex gap-8 px-8 pb-8 mt-4">
        <div className="flex-1 flex items-center justify-center bg-white rounded-lg shadow-lg">
          <canvas
            ref={crossSectionCanvasRef}
            width={400}
            height={400}
            className="border border-gray-300"
          />
        </div>

        <div className="w-80 space-y-6 overflow-auto">
          <div>
            <h2 className="mb-4">Cross Section Controls</h2>

            <div className="space-y-4">
              <div>
                <Label htmlFor="shape-cross">Shape Type</Label>
                <Select value={shapeType} onValueChange={(value) => setShapeType(value as ShapeType)}>
                  <SelectTrigger id="shape-cross">
                    <SelectValue />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="sphere">Sphere</SelectItem>
                    <SelectItem value="cube">Cube</SelectItem>
                    <SelectItem value="torus">Torus</SelectItem>
                    <SelectItem value="cylinder">Cylinder</SelectItem>
                    <SelectItem value="satellite">Satellite</SelectItem>
                    <SelectItem value="dish">Dish</SelectItem>
                    <SelectItem value="debris">Debris</SelectItem>
                    <SelectItem value="cross">Cross</SelectItem>
                    <SelectItem value="octahedron">Octahedron</SelectItem>
                    <SelectItem value="capsule">Capsule</SelectItem>
                  </SelectContent>
                </Select>
              </div>

              <div>
                <Label htmlFor="slicePosition">Slice Position: {slicePosition.toFixed(2)}</Label>
                <Slider
                  id="slicePosition"
                  min={-2}
                  max={2}
                  step={0.05}
                  value={[slicePosition]}
                  onValueChange={(value) => setSlicePosition(value[0])}
                />
              </div>

              <div>
                <Label htmlFor="crossPixelSize">Pixel Size: {crossPixelSize}px</Label>
                <Slider
                  id="crossPixelSize"
                  min={1}
                  max={10}
                  step={1}
                  value={[crossPixelSize]}
                  onValueChange={(value) => setCrossPixelSize(value[0])}
                />
              </div>

              <div>
                <Label htmlFor="crossDotSize">Dot Size: {crossDotSize}px</Label>
                <Slider
                  id="crossDotSize"
                  min={1}
                  max={10}
                  step={1}
                  value={[crossDotSize]}
                  onValueChange={(value) => setCrossDotSize(value[0])}
                />
              </div>

              <div>
                <Label htmlFor="shapeSize-cross">Shape Size: {shapeSize.toFixed(1)}</Label>
                <Slider
                  id="shapeSize-cross"
                  min={0.5}
                  max={2}
                  step={0.1}
                  value={[shapeSize]}
                  onValueChange={(value) => setShapeSize(value[0])}
                />
              </div>

              <div>
                <Label htmlFor="rotationX-cross">Rotation X: {rotationX}°</Label>
                <Slider
                  id="rotationX-cross"
                  min={0}
                  max={360}
                  step={5}
                  value={[rotationX]}
                  onValueChange={(value) => setRotationX(value[0])}
                />
              </div>

              <div>
                <Label htmlFor="rotationY-cross">Rotation Y: {rotationY}°</Label>
                <Slider
                  id="rotationY-cross"
                  min={0}
                  max={360}
                  step={5}
                  value={[rotationY]}
                  onValueChange={(value) => setRotationY(value[0])}
                />
              </div>
            </div>
          </div>
        </div>
      </TabsContent>
    </Tabs>
  );
}

// Helper function to check if a point is inside a shape
function isPointInShape(point: Vector3, shapeType: ShapeType, size: number): boolean {
  switch (shapeType) {
    case 'sphere':
      return isPointInSphere(point, size);
    case 'cube':
      return isPointInCube(point, size);
    case 'torus':
      return isPointInTorus(point, size);
    case 'cylinder':
      return isPointInCylinder(point, size);
    case 'satellite':
      return isPointInSatellite(point, size);
    case 'dish':
      return isPointInDish(point, size);
    case 'debris':
      return isPointInDebris(point, size);
    case 'cross':
      return isPointInCross(point, size);
    case 'octahedron':
      return isPointInOctahedron(point, size);
    case 'capsule':
      return isPointInCapsule(point, size);
    default:
      return false;
  }
}

function isPointInSphere(p: Vector3, size: number): boolean {
  const dist = Math.sqrt(p.x * p.x + p.y * p.y + p.z * p.z);
  return dist <= size;
}

function isPointInCube(p: Vector3, size: number): boolean {
  const half = size * 0.5;
  return Math.abs(p.x) <= half && Math.abs(p.y) <= half && Math.abs(p.z) <= half;
}

function isPointInTorus(p: Vector3, size: number): boolean {
  const R = size * 0.6;
  const r = size * 0.3;
  const distFromAxis = Math.sqrt(p.x * p.x + p.y * p.y);
  const dist = Math.sqrt((distFromAxis - R) ** 2 + p.z * p.z);
  return dist <= r;
}

function isPointInCylinder(p: Vector3, size: number): boolean {
  const radius = size * 0.5;
  const height = size;
  const distFromAxis = Math.sqrt(p.x * p.x + p.z * p.z);
  return distFromAxis <= radius && Math.abs(p.y) <= height / 2;
}

function isPointInSatellite(p: Vector3, size: number): boolean {
  const bodySize = size * 0.4;
  const panelWidth = size * 0.8;
  const panelThickness = size * 0.05;
  const panelHeight = size * 0.6;

  // Central body
  if (Math.abs(p.x) <= bodySize / 2 && Math.abs(p.y) <= bodySize / 2 && Math.abs(p.z) <= bodySize / 2) {
    return true;
  }

  // Left panel
  const leftPanelX = -size * 0.6;
  if (Math.abs(p.x - leftPanelX) <= panelWidth / 2 && Math.abs(p.y) <= panelHeight / 2 && Math.abs(p.z) <= panelThickness / 2) {
    return true;
  }

  // Right panel
  const rightPanelX = size * 0.6;
  if (Math.abs(p.x - rightPanelX) <= panelWidth / 2 && Math.abs(p.y) <= panelHeight / 2 && Math.abs(p.z) <= panelThickness / 2) {
    return true;
  }

  return false;
}

function isPointInDish(p: Vector3, size: number): boolean {
  const radius = size;
  const depth = size * 0.5;
  const r = Math.sqrt(p.x * p.x + p.y * p.y);
  if (r > radius) return false;
  
  const expectedZ = (r * r) / (4 * depth) - depth;
  return Math.abs(p.z - expectedZ) <= 0.05;
}

function isPointInDebris(p: Vector3, size: number): boolean {
  const pieces = [
    { center: { x: 0, y: 0, z: 0 }, size: size * 0.5, type: 'box' as const },
    { center: { x: size * 0.4, y: size * 0.3, z: 0 }, size: size * 0.3, type: 'sphere' as const },
    { center: { x: -size * 0.3, y: -size * 0.2, z: size * 0.2 }, size: size * 0.25, type: 'box' as const },
    { center: { x: 0, y: size * 0.4, z: -size * 0.3 }, size: size * 0.2, type: 'sphere' as const },
    { center: { x: size * 0.2, y: -size * 0.4, z: size * 0.1 }, size: size * 0.15, type: 'box' as const },
  ];

  for (const piece of pieces) {
    const relative = {
      x: p.x - piece.center.x,
      y: p.y - piece.center.y,
      z: p.z - piece.center.z,
    };

    if (piece.type === 'box') {
      const half = piece.size / 2;
      if (Math.abs(relative.x) <= half && Math.abs(relative.y) <= half && Math.abs(relative.z) <= half) {
        return true;
      }
    } else {
      const dist = Math.sqrt(relative.x ** 2 + relative.y ** 2 + relative.z ** 2);
      if (dist <= piece.size) {
        return true;
      }
    }
  }

  return false;
}

function isPointInCross(p: Vector3, size: number): boolean {
  const barLength = size;
  const barThickness = size * 0.15;
  const half = barThickness / 2;

  // X-axis bar
  if (Math.abs(p.x) <= barLength / 2 && Math.abs(p.y) <= half && Math.abs(p.z) <= half) {
    return true;
  }

  // Y-axis bar
  if (Math.abs(p.y) <= barLength / 2 && Math.abs(p.x) <= half && Math.abs(p.z) <= half) {
    return true;
  }

  // Z-axis bar
  if (Math.abs(p.z) <= barLength / 2 && Math.abs(p.x) <= half && Math.abs(p.y) <= half) {
    return true;
  }

  return false;
}

function isPointInOctahedron(p: Vector3, size: number): boolean {
  const dist = Math.abs(p.x) + Math.abs(p.y) + Math.abs(p.z);
  return dist <= size;
}

function isPointInCapsule(p: Vector3, size: number): boolean {
  const radius = size * 0.3;
  const halfHeight = size * 0.5;

  // Cylinder body
  const distFromAxis = Math.sqrt(p.x * p.x + p.z * p.z);
  if (distFromAxis <= radius && Math.abs(p.y) <= halfHeight) {
    return true;
  }

  // Top hemisphere
  if (p.y > halfHeight) {
    const dist = Math.sqrt(p.x ** 2 + (p.y - halfHeight) ** 2 + p.z ** 2);
    return dist <= radius;
  }

  // Bottom hemisphere
  if (p.y < -halfHeight) {
    const dist = Math.sqrt(p.x ** 2 + (p.y + halfHeight) ** 2 + p.z ** 2);
    return dist <= radius;
  }

  return false;
}

// Helper functions for 3D math
function rotatePoint(p: Vector3, rx: number, ry: number): Vector3 {
  let point = { ...p };

  // Rotate around X axis
  const cosX = Math.cos((rx * Math.PI) / 180);
  const sinX = Math.sin((rx * Math.PI) / 180);
  const y1 = point.y * cosX - point.z * sinX;
  const z1 = point.y * sinX + point.z * cosX;
  point.y = y1;
  point.z = z1;

  // Rotate around Y axis
  const cosY = Math.cos((ry * Math.PI) / 180);
  const sinY = Math.sin((ry * Math.PI) / 180);
  const x2 = point.x * cosY + point.z * sinY;
  const z2 = -point.x * sinY + point.z * cosY;
  point.x = x2;
  point.z = z2;

  return point;
}

function castRay(
  origin: Vector3,
  direction: Vector3,
  shapeType: ShapeType,
  rx: number,
  ry: number,
  size: number
): Vector3 | null {
  switch (shapeType) {
    case 'sphere':
      return raySphereIntersection(origin, direction, { x: 0, y: 0, z: 0 }, size);
    case 'cube':
      return rayCubeIntersection(origin, direction, rx, ry, size);
    case 'torus':
      return rayTorusIntersection(origin, direction, rx, ry, size);
    case 'cylinder':
      return rayCylinderIntersection(origin, direction, rx, ry, size);
    case 'satellite':
      return raySatelliteIntersection(origin, direction, rx, ry, size);
    case 'dish':
      return rayDishIntersection(origin, direction, rx, ry, size);
    case 'debris':
      return rayDebrisIntersection(origin, direction, rx, ry, size);
    case 'cross':
      return rayCrossIntersection(origin, direction, rx, ry, size);
    case 'octahedron':
      return rayOctahedronIntersection(origin, direction, rx, ry, size);
    case 'capsule':
      return rayCapsuleIntersection(origin, direction, rx, ry, size);
    default:
      return null;
  }
}

function raySphereIntersection(
  origin: Vector3,
  direction: Vector3,
  center: Vector3,
  radius: number
): Vector3 | null {
  const oc: Vector3 = {
    x: origin.x - center.x,
    y: origin.y - center.y,
    z: origin.z - center.z,
  };

  const a = direction.x * direction.x + direction.y * direction.y + direction.z * direction.z;
  const b = 2.0 * (oc.x * direction.x + oc.y * direction.y + oc.z * direction.z);
  const c = oc.x * oc.x + oc.y * oc.y + oc.z * oc.z - radius * radius;

  const discriminant = b * b - 4 * a * c;

  if (discriminant < 0) return null;

  const t = (-b - Math.sqrt(discriminant)) / (2.0 * a);

  if (t < 0) return null;

  return {
    x: origin.x + direction.x * t,
    y: origin.y + direction.y * t,
    z: origin.z + direction.z * t,
  };
}

function rayCubeIntersection(
  origin: Vector3,
  direction: Vector3,
  rx: number,
  ry: number,
  size: number
): Vector3 | null {
  const invOrigin = rotatePoint(origin, -rx, -ry);
  const invDir = rotatePoint(direction, -rx, -ry);

  const halfSize = size * 0.5;
  const min = { x: -halfSize, y: -halfSize, z: -halfSize };
  const max = { x: halfSize, y: halfSize, z: halfSize };

  const t1 = (min.x - invOrigin.x) / invDir.x;
  const t2 = (max.x - invOrigin.x) / invDir.x;
  const t3 = (min.y - invOrigin.y) / invDir.y;
  const t4 = (max.y - invOrigin.y) / invDir.y;
  const t5 = (min.z - invOrigin.z) / invDir.z;
  const t6 = (max.z - invOrigin.z) / invDir.z;

  const tmin = Math.max(Math.max(Math.min(t1, t2), Math.min(t3, t4)), Math.min(t5, t6));
  const tmax = Math.min(Math.min(Math.max(t1, t2), Math.max(t3, t4)), Math.max(t5, t6));

  if (tmax < 0 || tmin > tmax) return null;

  const t = tmin < 0 ? tmax : tmin;
  const hitPoint = {
    x: invOrigin.x + invDir.x * t,
    y: invOrigin.y + invDir.y * t,
    z: invOrigin.z + invDir.z * t,
  };

  return rotatePoint(hitPoint, rx, ry);
}

function rayTorusIntersection(
  origin: Vector3,
  direction: Vector3,
  rx: number,
  ry: number,
  size: number
): Vector3 | null {
  const invOrigin = rotatePoint(origin, -rx, -ry);
  const invDir = rotatePoint(direction, -rx, -ry);

  const R = size * 0.6;
  const r = size * 0.3;

  for (let t = 0; t < 5; t += 0.01) {
    const p = {
      x: invOrigin.x + invDir.x * t,
      y: invOrigin.y + invDir.y * t,
      z: invOrigin.z + invDir.z * t,
    };

    const distFromAxis = Math.sqrt(p.x * p.x + p.y * p.y);
    const dist = Math.sqrt((distFromAxis - R) ** 2 + p.z * p.z);

    if (dist < r) {
      return rotatePoint(p, rx, ry);
    }
  }

  return null;
}

function rayCylinderIntersection(
  origin: Vector3,
  direction: Vector3,
  rx: number,
  ry: number,
  size: number
): Vector3 | null {
  const invOrigin = rotatePoint(origin, -rx, -ry);
  const invDir = rotatePoint(direction, -rx, -ry);

  const radius = size * 0.5;
  const height = size;

  const a = invDir.x * invDir.x + invDir.z * invDir.z;
  const b = 2 * (invOrigin.x * invDir.x + invOrigin.z * invDir.z);
  const c = invOrigin.x * invOrigin.x + invOrigin.z * invOrigin.z - radius * radius;

  const discriminant = b * b - 4 * a * c;
  if (discriminant < 0) return null;

  const t1 = (-b - Math.sqrt(discriminant)) / (2 * a);
  const t2 = (-b + Math.sqrt(discriminant)) / (2 * a);

  for (const t of [t1, t2]) {
    if (t > 0) {
      const y = invOrigin.y + invDir.y * t;
      if (Math.abs(y) <= height / 2) {
        const hitPoint = {
          x: invOrigin.x + invDir.x * t,
          y: y,
          z: invOrigin.z + invDir.z * t,
        };
        return rotatePoint(hitPoint, rx, ry);
      }
    }
  }

  return null;
}

function raySatelliteIntersection(
  origin: Vector3,
  direction: Vector3,
  rx: number,
  ry: number,
  size: number
): Vector3 | null {
  const invOrigin = rotatePoint(origin, -rx, -ry);
  const invDir = rotatePoint(direction, -rx, -ry);

  const bodySize = size * 0.4;
  const bodyHit = checkBox(invOrigin, invDir, { x: 0, y: 0, z: 0 }, bodySize);

  const panelWidth = size * 0.8;
  const panelThickness = size * 0.05;
  const panelHeight = size * 0.6;
  const leftPanel = checkBox(invOrigin, invDir, { x: -size * 0.6, y: 0, z: 0 }, panelWidth, panelHeight, panelThickness);
  const rightPanel = checkBox(invOrigin, invDir, { x: size * 0.6, y: 0, z: 0 }, panelWidth, panelHeight, panelThickness);

  const hits = [bodyHit, leftPanel, rightPanel].filter(h => h !== null) as Vector3[];
  if (hits.length === 0) return null;

  const closest = hits.reduce((a, b) => {
    const distA = Math.sqrt((a.x - invOrigin.x) ** 2 + (a.y - invOrigin.y) ** 2 + (a.z - invOrigin.z) ** 2);
    const distB = Math.sqrt((b.x - invOrigin.x) ** 2 + (b.y - invOrigin.y) ** 2 + (b.z - invOrigin.z) ** 2);
    return distA < distB ? a : b;
  });

  return rotatePoint(closest, rx, ry);
}

function rayDishIntersection(
  origin: Vector3,
  direction: Vector3,
  rx: number,
  ry: number,
  size: number
): Vector3 | null {
  const invOrigin = rotatePoint(origin, -rx, -ry);
  const invDir = rotatePoint(direction, -rx, -ry);

  const radius = size;
  const depth = size * 0.5;

  for (let t = 0; t < 5; t += 0.01) {
    const p = {
      x: invOrigin.x + invDir.x * t,
      y: invOrigin.y + invDir.y * t,
      z: invOrigin.z + invDir.z * t,
    };

    const r = Math.sqrt(p.x * p.x + p.y * p.y);
    if (r > radius) continue;

    const expectedZ = (r * r) / (4 * depth) - depth;

    if (Math.abs(p.z - expectedZ) < 0.02) {
      return rotatePoint(p, rx, ry);
    }
  }

  return null;
}

function rayDebrisIntersection(
  origin: Vector3,
  direction: Vector3,
  rx: number,
  ry: number,
  size: number
): Vector3 | null {
  const invOrigin = rotatePoint(origin, -rx, -ry);
  const invDir = rotatePoint(direction, -rx, -ry);

  const hits: Vector3[] = [];

  const pieces = [
    { center: { x: 0, y: 0, z: 0 }, size: size * 0.5, type: 'box' },
    { center: { x: size * 0.4, y: size * 0.3, z: 0 }, size: size * 0.3, type: 'sphere' },
    { center: { x: -size * 0.3, y: -size * 0.2, z: size * 0.2 }, size: size * 0.25, type: 'box' },
    { center: { x: 0, y: size * 0.4, z: -size * 0.3 }, size: size * 0.2, type: 'sphere' },
    { center: { x: size * 0.2, y: -size * 0.4, z: size * 0.1 }, size: size * 0.15, type: 'box' },
  ];

  for (const piece of pieces) {
    if (piece.type === 'box') {
      const hit = checkBox(invOrigin, invDir, piece.center, piece.size);
      if (hit) hits.push(hit);
    } else {
      const hit = checkSphere(invOrigin, invDir, piece.center, piece.size);
      if (hit) hits.push(hit);
    }
  }

  if (hits.length === 0) return null;

  const closest = hits.reduce((a, b) => {
    const distA = Math.sqrt((a.x - invOrigin.x) ** 2 + (a.y - invOrigin.y) ** 2 + (a.z - invOrigin.z) ** 2);
    const distB = Math.sqrt((b.x - invOrigin.x) ** 2 + (b.y - invOrigin.y) ** 2 + (b.z - invOrigin.z) ** 2);
    return distA < distB ? a : b;
  });

  return rotatePoint(closest, rx, ry);
}

function rayCrossIntersection(
  origin: Vector3,
  direction: Vector3,
  rx: number,
  ry: number,
  size: number
): Vector3 | null {
  const invOrigin = rotatePoint(origin, -rx, -ry);
  const invDir = rotatePoint(direction, -rx, -ry);

  const barLength = size;
  const barThickness = size * 0.15;

  const hits: Vector3[] = [];

  const xBar = checkBox(invOrigin, invDir, { x: 0, y: 0, z: 0 }, barLength, barThickness, barThickness);
  if (xBar) hits.push(xBar);

  const yBar = checkBox(invOrigin, invDir, { x: 0, y: 0, z: 0 }, barThickness, barLength, barThickness);
  if (yBar) hits.push(yBar);

  const zBar = checkBox(invOrigin, invDir, { x: 0, y: 0, z: 0 }, barThickness, barThickness, barLength);
  if (zBar) hits.push(zBar);

  if (hits.length === 0) return null;

  const closest = hits.reduce((a, b) => {
    const distA = Math.sqrt((a.x - invOrigin.x) ** 2 + (a.y - invOrigin.y) ** 2 + (a.z - invOrigin.z) ** 2);
    const distB = Math.sqrt((b.x - invOrigin.x) ** 2 + (b.y - invOrigin.y) ** 2 + (b.z - invOrigin.z) ** 2);
    return distA < distB ? a : b;
  });

  return rotatePoint(closest, rx, ry);
}

function rayOctahedronIntersection(
  origin: Vector3,
  direction: Vector3,
  rx: number,
  ry: number,
  size: number
): Vector3 | null {
  const invOrigin = rotatePoint(origin, -rx, -ry);
  const invDir = rotatePoint(direction, -rx, -ry);

  for (let t = 0; t < 5; t += 0.01) {
    const p = {
      x: invOrigin.x + invDir.x * t,
      y: invOrigin.y + invDir.y * t,
      z: invOrigin.z + invDir.z * t,
    };

    const dist = Math.abs(p.x) + Math.abs(p.y) + Math.abs(p.z);

    if (Math.abs(dist - size) < 0.02) {
      return rotatePoint(p, rx, ry);
    }
  }

  return null;
}

function rayCapsuleIntersection(
  origin: Vector3,
  direction: Vector3,
  rx: number,
  ry: number,
  size: number
): Vector3 | null {
  const invOrigin = rotatePoint(origin, -rx, -ry);
  const invDir = rotatePoint(direction, -rx, -ry);

  const radius = size * 0.3;
  const halfHeight = size * 0.5;

  const a = invDir.x * invDir.x + invDir.z * invDir.z;
  const b = 2 * (invOrigin.x * invDir.x + invOrigin.z * invDir.z);
  const c = invOrigin.x * invOrigin.x + invOrigin.z * invOrigin.z - radius * radius;

  const discriminant = b * b - 4 * a * c;

  if (discriminant >= 0) {
    const t1 = (-b - Math.sqrt(discriminant)) / (2 * a);
    const t2 = (-b + Math.sqrt(discriminant)) / (2 * a);

    for (const t of [t1, t2]) {
      if (t > 0) {
        const y = invOrigin.y + invDir.y * t;
        if (Math.abs(y) <= halfHeight) {
          const hitPoint = {
            x: invOrigin.x + invDir.x * t,
            y: y,
            z: invOrigin.z + invDir.z * t,
          };
          return rotatePoint(hitPoint, rx, ry);
        }
      }
    }
  }

  const topSphere = checkSphere(invOrigin, invDir, { x: 0, y: halfHeight, z: 0 }, radius);
  if (topSphere && topSphere.y >= halfHeight) return rotatePoint(topSphere, rx, ry);

  const bottomSphere = checkSphere(invOrigin, invDir, { x: 0, y: -halfHeight, z: 0 }, radius);
  if (bottomSphere && bottomSphere.y <= -halfHeight) return rotatePoint(bottomSphere, rx, ry);

  return null;
}

function checkBox(
  origin: Vector3,
  direction: Vector3,
  center: Vector3,
  width: number,
  height?: number,
  depth?: number
): Vector3 | null {
  const w = width / 2;
  const h = (height || width) / 2;
  const d = (depth || width) / 2;

  const min = { x: center.x - w, y: center.y - h, z: center.z - d };
  const max = { x: center.x + w, y: center.y + h, z: center.z + d };

  const t1 = (min.x - origin.x) / direction.x;
  const t2 = (max.x - origin.x) / direction.x;
  const t3 = (min.y - origin.y) / direction.y;
  const t4 = (max.y - origin.y) / direction.y;
  const t5 = (min.z - origin.z) / direction.z;
  const t6 = (max.z - origin.z) / direction.z;

  const tmin = Math.max(Math.max(Math.min(t1, t2), Math.min(t3, t4)), Math.min(t5, t6));
  const tmax = Math.min(Math.min(Math.max(t1, t2), Math.max(t3, t4)), Math.max(t5, t6));

  if (tmax < 0 || tmin > tmax) return null;

  const t = tmin < 0 ? tmax : tmin;
  return {
    x: origin.x + direction.x * t,
    y: origin.y + direction.y * t,
    z: origin.z + direction.z * t,
  };
}

function checkSphere(
  origin: Vector3,
  direction: Vector3,
  center: Vector3,
  radius: number
): Vector3 | null {
  const oc: Vector3 = {
    x: origin.x - center.x,
    y: origin.y - center.y,
    z: origin.z - center.z,
  };

  const a = direction.x * direction.x + direction.y * direction.y + direction.z * direction.z;
  const b = 2.0 * (oc.x * direction.x + oc.y * direction.y + oc.z * direction.z);
  const c = oc.x * oc.x + oc.y * oc.y + oc.z * oc.z - radius * radius;

  const discriminant = b * b - 4 * a * c;

  if (discriminant < 0) return null;

  const t = (-b - Math.sqrt(discriminant)) / (2.0 * a);

  if (t < 0) return null;

  return {
    x: origin.x + direction.x * t,
    y: origin.y + direction.y * t,
    z: origin.z + direction.z * t,
  };
}

function project3DTo2D(point: Vector3, width: number, height: number): { x: number; y: number } | null {
  const fov = 800;
  const scale = fov / (point.z + 5);

  const x = point.x * scale + width / 2;
  const y = point.y * scale + height / 2;

  if (x < 0 || x > width || y < 0 || y > height) return null;

  return { x, y };
}